МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з лабораторної роботи № 4 з дисципліни
скриптові мови програмування





Виконала:                                                                           Перевірив:
ст. гр. ПЗПІ-23-5                        				ст. викладач кафедри ПІ
Самосватова А.Р.						          Сокорчук Ігор Петрович










Харків 2025

ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень        131.05.20250.1Початкова версія              
      

ЗАВДАННЯ

     Використовуючи матеріал попередніх лабораторних робіт, потрібно додати такий функціонал:
     1. Прибрати дублювання шапки і підвалу сайту (якщо воно є).
     2. Додати сторінку логіна. Обмежити доступ до сайту не залогіненим
     користувачам.
     3. Додати сторінку профілю з можливістю завантажити фото.

ХІД РОБОТИ
     У PHP-скрипті maim.php за допомогою функції session_start() ініціалізується сесія, що дозволяє зберігати дані користувача під час роботи з веб-додатком. Далі підключається файл db.php, який встановлює з’єднання з базою даних через об’єкт PDO. У секції HTML вказується мета-інформація сторінки, підключається зовнішній файл стилів і через команду require_once("header.php") вставляється загальний шаблон шапки сайту. Основна частина контенту формується в блоці <main>, де за допомогою змінної $page, яка отримується з параметра $_GET['page'] або має значення за замовчуванням 'home', визначається, яку сторінку необхідно відобразити.
     
      1. <?php
      2. session_start();
      3. require_once 'db.php';
      4. ?>
      5. <!DOCTYPE html>
      6. <html lang="en">
      7. <head>
      8.     <meta charset="UTF-8">
      9.     <title>Web-магазин</title>
      10.     <link rel="stylesheet" href="style.css">
      11. </head>
      12. <body>
      13. 
      14. <?php require_once("header.php"); ?>
      15. 
      16. <main>
      17. <?php
      18. $page = $_GET['page'] ?? 'home';
      19.
     
      Далі відбувається перевірка: якщо користувач не авторизований (тобто в сесії відсутній ключ 'user'), а поточна сторінка не є сторінкою входу, то користувача автоматично перенаправляють на сторінку з помилкою, підключаючи page404.php. 
     
      20. if (!isset($_SESSION['user']) && $page !== 'login') {
      21.    require_once("page404.php");
     Якщо ж користувач авторизований або перебуває на сторінці входу, за допомогою конструкції switch виконується підключення відповідного файлу залежно від значення $page. Зокрема, для значення 'cart' підключається сторінка кошика, для 'products' — каталог товарів, для 'profile' — сторінка профілю, для 'login' — форма входу, для 'logout' — процедура виходу із системи, для 'home' — головна сторінка із привітанням та посиланням на каталог. 
     
      22. } else {
      23.     switch ($page) {
      24.         case 'cart':
      25.             require_once("cart.php");
      26.             break;
      27.         case 'products':
      28.             require_once("product.php");
      29.             break;
      30.         case 'profile':
      31.             require_once("profile.php");
      32.             break;
      33.         case 'login':
      34.             require_once("login.php");
      35.             break;
      36.         case 'logout':
      37.             require_once("logout.php");
      38.             break;
      39.         case 'home':
      40.            echo "<h2>Welcome to Web-shop</h2>
      41.       <p>Go to the <a href=\"main.php?page=products\">Products</a> tab to view the range of items.</p>";
      42. 
      43.             break;
     
     Якщо жодне із заданих значень не співпадає, підключається сторінка помилки page404.php. Наприкінці викликається footer.php, що вставляє нижню частину сторінки.
     
      44.         default:
      45.             require_once("page404.php");
      46.             break;
      47.     }
      48. }
      49. ?>
      50. </main>
      51. 
      52. <?php require_once("footer.php"); ?>
      53. 
      54. </body>
      55. </html>
      56.
     
     У db.php здійснюється підключення до бази даних SQLite за допомогою об’єкта PDO. Команда new PDO('sqlite:simple_shop.db') створює новий екземпляр з’єднання з файлом бази даних simple_shop.db, який розміщується у кореневій директорії проєкту. Далі методом setAttribute встановлюється режим обробки помилок PDO::ERRMODE_EXCEPTION, що дозволяє генерувати винятки у випадку виникнення помилок під час виконання SQL-запитів або роботи з базою. Якщо при спробі встановлення з’єднання виникає помилка ( файл бази відсутній або пошкоджений), вона перехоплюється у блоці catch, де обробляється виняток типу PDOException, і програма завершує виконання за допомогою функції die(), виводячи повідомлення про помилку із зазначенням її змісту. 
     
      1. <?php
      2. try {
      3.     $pdo = new PDO('sqlite:simple_shop.db');
      4.     $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
      5. } catch (PDOException $e) {
      6.     die("SQLite connection failed: " . $e->getMessage());
      7. }
      8. ?>
      9.

     У першому рядку файлу product.php відкривається PHP-тег <?php, що означає початок виконання PHP-коду. Далі за допомогою конструкції require_once 'db.php' підключається файл з налаштуваннями підключення до бази даних SQLite, що дозволяє надалі використовувати об’єкт $pdo для виконання SQL-запитів.
     
      1. <?php
      2. require_once 'db.php';
      
     Далі відбувається перевірка типу HTTP-запиту. Якщо поточний запит є POST-запитом (тобто сторінка отримала дані з форми методом POST), тоді виконується обробка надісланих даних. Для цього із суперглобального масиву $_POST зчитуються два масиви: product_id та quantity. Якщо жоден з них не переданий, за замовчуванням використовується порожній масив (через оператор ?? []).
      3. 
      4. if ($_SERVER['REQUEST_METHOD'] === 'POST') {
      5.     $productIds = $_POST['product_id'] ?? [];
      6.     $quantities = $_POST['quantity'] ?? [];
      7.
     
     Далі за допомогою циклу foreach перебираються всі передані ідентифікатори товарів $productIds. Для кожного елемента визначається його кількість $qty, яку користувач вказав у відповідному полі форми. Ідентифікатор товару $productId та кількість $qty примусово приводяться до цілочисельного типу за допомогою (int) для запобігання помилкам чи некоректним даним.
     Після цього відбувається перевірка: якщо кількість $qty більше 0, то виконується вставка нового запису у таблицю cart. Для цього створюється підготовлений запит методом prepare() з SQL-інструкцією INSERT INTO cart (product_id, quantity) VALUES (?, ?), яка дозволяє безпечно передавати значення у запит. Далі викликається метод execute() і передається масив із двох елементів — ідентифікатора товару та його кількості. Після завершення циклу користувача перенаправляють на сторінку cart.php за допомогою функції  header('Location: ?page=cart') , а виконання скрипта припиняється командою exit.
     
      8.     foreach ($productIds as $index => $productId) {
      9.         $qty = (int)($quantities[$index] ?? 0);
      10.         $productId = (int)$productId;
      11. 
      12.         if ($qty > 0) {
      13.            
      14.             $stmt = $pdo->prepare("INSERT INTO cart (product_id, quantity) VALUES (?, ?)");
      15.             $stmt->execute([$productId, $qty]);
      16.         }
      17.     }
      18.      header('Location: ?page=cart');
      19.     exit;
      20. }
     
     Далі виконується запит до бази даних для отримання списку всіх товарів. Це здійснюється методом query() з SQL-інструкцією SELECT * FROM products. Отримані результати перетворюються у масив асоціативних масивів за допомогою методу fetchAll(PDO::FETCH_ASSOC) і зберігаються у змінній $products. Після чого виконується запит для визначення кількості товарів у кошику. Для цього методом query() виконується SQL-інструкція SELECT COUNT(*) FROM cart, яка повертає кількість записів у таблиці cart. Результат зчитується методом fetchColumn() і записується у змінну $cartCount.
      
      21. 
      22. 
      23. $products = $pdo->query("SELECT * FROM products")->fetchAll(PDO::FETCH_ASSOC);
      24. 
      25. $countStmt = $pdo->query("SELECT COUNT(*) FROM cart");
      26. $cartCount = $countStmt->fetchColumn();
      27. ?>
      
     Основна частина сторінки міститься між тегами <body>. Спочатку виводиться заголовок у блоці <header> із текстом Product Catalog. Далі формується меню навігації в блоці <nav>, яке містить посилання на головну сторінку, каталог товарів та кошик. У посиланні на кошик динамічно виводиться кількість товарів у кошику, отримана раніше за допомогою PHP-вставки <?= $cartCount ?>.
     Основний контент сторінки розміщується в блоці <main>. Спочатку виводиться заголовок другого рівня <h2>Products</h2>. Далі розташовується форма з атрибутом method="post", що дозволяє надсилати дані на цю ж сторінку методом POST. У середині форми є контейнер <div class="products-list">, всередині якого за допомогою циклу foreach виводяться всі товари з масиву $products.
     
      28. 
      29. <!DOCTYPE html>
      30. <html lang="en">
      31. <head>
      32. <meta charset="UTF-8">
      33. <title>Product Catalog</title>
      34. <link rel="stylesheet" href="style.css">
      35. </head>
      36. <body>
      37. <header>Product Catalog</header>
      38. <nav>
      39.   <a href="index.php">Home</a>
      40.   <a href="product.php">Catalog</a>
      41.   <a href="cart.php">Basket (<?= $cartCount ?>)</a>
      42. </nav>
      43. <main>
      44. <h2>Products</h2>
      45. 
      46. <form method="post">
      47.   <div class="products-list">
      48.     <?php foreach ($products as $product): ?>
      
     Для кожного товару формується блок <div class="product-item">, який містить назву товару, його вартість у форматі доларів з двома знаками після коми, приховане поле <input type="hidden"> з ідентифікатором товару та поле введення <input type="number"> для вибору кількості товару. Мінімальне допустиме значення кількості — 0, а початкове значення встановлюється у 0.
     
      49.     <div class="product-item">
      50.       <div><?= htmlspecialchars($product['name']) ?> — $<?= number_format($product['cost'], 2) ?></div>
      51.       <input type="hidden" name="product_id[]" value="<?= $product['id'] ?>">
      52.       <input type="number" name="quantity[]" min="0" value="0">
      53.     </div>
      54.     <?php endforeach; ?>
      55.   </div>
      
     Після виведення всіх товарів формується кнопка <button type="submit">Add Selected to Cart</button>, яка дозволяє користувачеві додати вибрані товари до кошика. Наприкінці сторінки у блоці <footer> виводиться копірайт із поточним роком, який автоматично підставляється за допомогою PHP-функції date('Y').
     
      56.   <button type="submit">Add Selected to Cart</button>
      57. </form>
      58. 
      59. </main>
      60. <footer>© <?= date('Y') ?> PHP Shop.</footer>
      61. </body>
      62. </html>
      
     На початку файлу cart.php відкривається PHP-блок <?php, після чого за допомогою конструкції require 'db.php' підключається файл із налаштуваннями підключення до бази даних, щоб отримати доступ до об’єкта $pdo для виконання SQL-запитів. Далі виконується перевірка, чи був запит до сторінки виконаний методом POST і чи передано у ньому параметр remove_id. Якщо так, то значення цього параметра зчитується у змінну $removeId та примусово перетворюється на ціле число для захисту від помилкових або шкідливих значень. Після цього формується підготовлений SQL-запит для видалення товару з кошика. Для цього викликається метод prepare() з SQL-інструкцією DELETE FROM cart WHERE id = ?, яка дозволяє безпечно передавати параметри до запиту. Методом execute() передається масив із єдиним елементом — ідентифікатором рядка, який потрібно видалити.
     Після виконання запиту відбувається перенаправлення користувача на цю ж сторінку cart.php командою  header('Location: ?page=cart'), що дозволяє уникнути повторного надсилання форми при оновленні сторінки. Далі скрипт примусово завершується командою exit.
     
      1. <?php
      2. require 'db.php';
      3. 
      4. if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_POST['remove_id'])) {
      5.     $removeId = (int)$_POST['remove_id'];
      6.     $stmt = $pdo->prepare("DELETE FROM cart WHERE id = ?");
      7.     $stmt->execute([$removeId]);
      8.      header('Location: ?page=cart');
      9.     exit;
      10. }
     
     Виконується вибірка всіх товарів у кошику. Для цього формується SQL-запит методом query(), у якому здійснюється об’єднання двох таблиць cart і products за допомогою операції JOIN по полю product_id. Це дозволяє отримати інформацію про назву товару, його вартість, кількість у кошику та відповідні ідентифікатори. Результати запиту перетворюються у масив асоціативних масивів за допомогою методу fetchAll(PDO::FETCH_ASSOC) і зберігаються у змінній $cartItems.
      
11. 
12. 
13. $stmt = $pdo->query("SELECT cart.id AS cart_id, products.id AS product_id, products.name, products.cost, cart.quantity
14.                      FROM cart
15.                      JOIN products ON cart.product_id = products.id");
16. $cartItems = $stmt->fetchAll(PDO::FETCH_ASSOC);
17. ?>

     Далі починається HTML-розмітка сторінки, яка оголошується тегом <!DOCTYPE html> і відкривається тегом <html> із атрибутом lang="en". У блоці <head> задається кодування UTF-8, заголовок сторінки <title>Your Cart</title> та підключається таблиця стилів style.css.
     У блоці <body> формується заголовок сторінки у блоці <header> із текстом Your Basket. Далі створюється навігаційне меню в блоці <nav>, яке містить посилання на головну сторінку, каталог товарів та кошик. У посиланні на кошик динамічно виводиться кількість товарів у кошику, що визначається функцією count($cartItems) — тобто кількістю елементів у масиві товарів.
     Основний вміст сторінки розташовується в блоці <main>. Тут спочатку виводиться заголовок <h2>Cart</h2>. Далі за допомогою умовного виразу if (!empty($cartItems)) перевіряється, чи є в кошику товари. Якщо так — формується таблиця з товарами.
     
      18. 
      19. <!DOCTYPE html>
      20. <html lang="en">
      21. <head>
      22. <meta charset="UTF-8">
      23. <title>Your Cart</title>
      24. <link rel="stylesheet" href="style.css">
      25. </head>
      26. <body>
      27. <header>Your Basket</header>
      28. <nav>
      29.   <a href="index.php">Home</a>
      30.   <a href="product.php">Catalog</a>
      31.   <a href="cart.php">Basket (<?= count($cartItems) ?>)</a>
      32. </nav>
      33. <main>
      34. <h2>Cart</h2>
      35. 
      36. <?php if (!empty($cartItems)): ?>
     
     Таблиця починається з заголовків колонок: Product, Price, Quantity, Sum та пустої колонки для кнопки видалення. Далі визначається змінна $total, яка слугуватиме для підрахунку загальної суми кошика.
     Циклом foreach перебираються всі товари у масиві $cartItems. Для кожного товару обчислюється проміжна сума рядка $lineSum як добуток ціни товару на його кількість, а також до загальної суми додається значення $lineSum.
     
37. <table>
38. <thead>
39.   <tr>
40.     <th>Product</th>
41.     <th>Price</th>
42.     <th>Quantity</th>
43.     <th>Sum</th>
44.     <th></th>
45.   </tr>
46. </thead>
47. <tbody>
48. <?php
49. $total = 0;
50. foreach ($cartItems as $item):
51.     $lineSum = $item['cost'] * $item['quantity'];
52.     $total += $lineSum;
53. ?>

      У кожному рядку таблиці відображаються: назва товару, 
     * Ціна товару.
     * Кількість товару.
     * Проміжна сума рядка.
     * Кнопка для видалення товару з кошика, яка реалізована через форму з прихованим полем remove_id, що містить ідентифікатор рядка кошика, та кнопкою Remove.
      
      54. <tr>
      55.   <td><?= htmlspecialchars($item['name']) ?></td>
      56.   <td>$<?= number_format($item['cost'], 2) ?></td>
      57.   <td><?= $item['quantity'] ?></td>
      58.   <td>$<?= number_format($lineSum, 2) ?></td>
      59.   <td>
      60.     <form method="post" style="display:inline">
      61.       <input type="hidden" name="remove_id" value="<?= $item['cart_id'] ?>">
      62.       <button type="submit">Remove</button>
      63.     </form>
      64.   </td>
      65. </tr> 

     Після виведення всіх товарів формується підсумковий рядок таблиці, у якому вказується загальна сума кошика, форматована у вигляді доларів з двома знаками після коми. 
     
      68.   <th colspan="3">Total</th>
      69.   <th colspan="2">$<?= number_format($total, 2) ?></th>
      70. </tr>
      71. </tbody>
      72. </table>
      73. 
      
     Якщо кошик порожній, у блоці else виводиться повідомлення Your basket is empty. та посилання на сторінку каталогу товарів product.php. Наприкінці сторінки у блоці <footer> виводиться копірайт із поточним роком за допомогою PHP-функції date('Y'). 
      74. <?php else: ?>
      75. <p>Your basket is empty. <a href="main.php?page=products">Go to catalog</a></p>
      76. <?php endif; ?>
      77. 
      78. </main>
      79. <footer>© <?= date('Y') ?> PHP Shop.</footer>
      80. </body>
      81. </html> 

     У файлі header.php реалізується динамічне формування верхньої частини веб-сторінки (хедера) з меню навігації для онлайн-магазину. Спочатку оголошується змінна $cartCount, якій присвоюється початкове значення 0. Далі перевіряється, чи встановлено у сесії параметр user, що свідчить про авторизованого користувача. Якщо так — виконується підготовлений SQL-запит до таблиці cart, де обчислюється кількість рядків (товарів у кошику) за допомогою функції COUNT(id). Після виконання запиту кількість зчитується методом fetchColumn() і присвоюється змінній $cartCount. Якщо кошик порожній, замість null встановлюється 0 за допомогою оператора об’єднання з 0 (?: 0).
Далі формується HTML-розмітка блоку <header>, де виводиться заголовок магазину та меню навігації. До меню включено посилання на сторінки Home, Catalog, Basket, при цьому поряд із пунктом Basket виводиться поточна кількість товарів у кошику. Також передбачено умовне відображення пунктів меню залежно від авторизації користувача: якщо користувач авторизований, з’являються посилання на Profile та Logout, якщо ні — пропонується перейти на сторінку Login.

1. <?php
2. $cartCount = 0;
3. if (isset($_SESSION['user'])) {
4.     $stmt = $pdo->prepare("SELECT COUNT(id) as total FROM cart");
5.     $stmt->execute();
6.     $cartCount = $stmt->fetchColumn() ?: 0;
7. }
8. ?>
9. <header>
10.   <h1>Web-магазин</h1>
11.   <nav>
12.     <a href="main.php?page=home">Home</a>
13.     <a href="main.php?page=products">Catalog</a>
14.     <a href="main.php?page=cart">Basket (<?= $cartCount ?>)</a>
15.     <?php if (isset($_SESSION['user'])): ?>
16.       <a href="main.php?page=profile">Profile</a>
17.       <a href="main.php?page=logout">Logout</a>
18.     <?php else: ?>
19.       <a href="main.php?page=login">Login</a>
20.     <?php endif; ?>
21.   </nav>
22. </header>
23.

     У в файлі пщщеукюзрз реалізовано виведення нижнього колонтитула (footer) веб-сторінки онлайн-магазину. У межах HTML-елемента <footer> розміщується текстовий рядок, який містить знак авторського права (©) і поточний рік, що автоматично визначається за допомогою PHP-функції date('Y'). Завдяки цьому рік у футері оновлюється автоматично відповідно до системної дати сервера, без необхідності змінювати код вручну. Після року виводиться назва магазину — Web-магазин. 

1. <footer>
2.   © <?= date('Y') ?> Web-магазин.
3. </footer>
4. 

     У цьому файлі login.php реалізовано авторизацію користувача через форму входу. Спершу перевіряється, чи запит виконано методом POST. Далі підключається файл credential.php, який містить масив зареєстрованих користувачів і їхніх паролів. Змінні $login і $password отримують значення, введені користувачем у форму, із попереднім видаленням зайвих пробілів за допомогою функції trim().
Відбувається перевірка: якщо введений логін існує у масиві $users, і відповідний йому пароль збігається з введеним, у сесії зберігається ім’я користувача, і відбувається перенаправлення на головну сторінку сайту. Якщо дані неправильні - формується повідомлення про помилку $error, яке виводиться червоним кольором над формою.

1. <?php
2. if ($_SERVER['REQUEST_METHOD'] === 'POST') {
3.     require_once 'credential.php';
4.     $login = trim($_POST['login'] ?? '');
5.     $password = trim($_POST['password'] ?? '');
6. 
7.     if (isset($users[$login]) && $users[$login] === $password) {
8.         $_SESSION['user'] = $login;
9.         header('Location: main.php?page=home');
10.         exit;
11.     } else {
12.         $error = "Invalid login or password.";
13.     }
14. }
15. ?>
16. 
17. <h2>Login</h2>
18. <?php if (isset($error)) echo "<p style='color:red;'>$error</p>"; ?>

     Далі наведено HTML-форму з двома полями для введення логіна та пароля. Кожне поле обов’язкове для заповнення (завдяки атрибуту required). Після натискання кнопки Log In дані надсилаються на цю ж сторінку для подальшої обробки. 
     
      19. 
      20. <form method="post">
      21.     <label>Login:
      22.         <input type="text" name="login" required>
      23.     </label>
      24.     <br>
      25.     <label>Password:
      26.         <input type="password" name="password" required>
      27.     </label>
      28.     <br>
      29.     <button type="submit">Log In</button>
      30. </form>
      

     В файлі logout.php реалізовано вихід користувача із системи. За допомогою функції session_destroy() видаляється поточна сесія користувача разом із усіма збереженими в ній даними, зокрема й авторизаційною інформацією. Після цього за допомогою функції header() виконується перенаправлення на сторінку входу (login), що дозволяє користувачу повторно пройти авторизацію, якщо потрібно. Команда exit зупиняє подальше виконання скрипта після перенаправлення, гарантуючи, що більше жоден рядок коду не буде виконаний.
     
      1. <?php
      2. session_destroy();
      3. header('Location: main.php?page=login');
      4. exit;
      5. ?>
      6.

     В файлі credential.php створено асоціативний масив $users, який містить список зареєстрованих користувачів системи та їхні паролі. Ключами масиву є логіни користувачів, а значеннями — відповідні паролі Цей масив використовується для перевірки введених даних під час авторизації, співставляючи логін і пароль користувача з даними з масиву. 
     
      1. <?php
      2. $users = 
      3. [
      4.     'admin' => 'admin123',
      5. ];
      6. ?>

     На початку роботи PHP-скрипта profule.php виконується запуск сесії, що дозволяє використовувати сесійні змінні для збереження інформації про авторизованого користувача. Далі перевіряється, чи існує в сесії значення user, яке вказує на авторизацію користувача. Якщо такого значення немає, користувача автоматично перенаправляють на сторінку авторизації.
     
      1. <?php
      2. session_start();
      3. if (!isset($_SESSION['user'])) {
      4.     header('Location: main.php?page=login');
      5.     exit;
      6. }
     До скрипта підключається файл profile_data.php, який містить масив $profile із збереженими даними користувача. Створюється порожній масив $errors, у який згодом додаватимуться повідомлення про помилки при заповненні форми.
     
      8. require_once 'profile_data.php';
      9. 
      10. $errors = [];
     
     Далі перевіряється, чи було виконано надсилання форми методом POST. Якщо так, зчитуються значення полів форми: ім'я, прізвище, дата народження, опис та фото. Після цього виконується перевірка кожного введеного значення. Ім'я та прізвище обов’язково повинні містити мінімум два символи. Вік користувача обчислюється на основі введеної дати народження, і якщо він менше 16 років — до масиву помилок додається відповідне повідомлення. Опис профілю повинен містити не менше 50 символів.

11. 
12. if ($_SERVER['REQUEST_METHOD'] === 'POST') {
13.     $firstname   = trim($_POST['firstname'] ?? '');
14.     $lastname    = trim($_POST['lastname'] ?? '');
15.     $birthdate   = $_POST['birthdate'] ?? '';
16.     $description = trim($_POST['description'] ?? '');
17.     $photoPath   = $profile['photo'];
18. 
19.     if (strlen($firstname) < 2) $errors[] = 'First name is required and must be at least 2 characters.';
20.     if (strlen($lastname) < 2 ) $errors[] = 'Last name is required and must be at least 2 characters.';
21. 
22.     $age = (int)date_diff(date_create($birthdate), date_create('now'))->y;
23.     if ($age < 16) $errors[] = 'You must be at least 16 years old.';
24. 
25.     if (strlen($description) < 50) $errors[] = 'Description must be at least 50 characters.';

     Якщо користувач завантажив фотографію, і вона пройшла перевірку на відсутність помилок під час передачі, файл зберігається у папці uploads/. Якщо такої папки не існує, вона створюється. Файл перейменовується шляхом додавання до його імені поточного часу, щоб уникнути перезапису існуючих файлів із однаковою назвою.
     
      26. 
      27.     if (isset($_FILES['photo']) && $_FILES['photo']['error'] === UPLOAD_ERR_OK) {
      28.         $uploadDir = 'uploads/';
      29.         if (!is_dir($uploadDir)) mkdir($uploadDir);
      30. 
      31.         $fileName = time() . '_' . basename($_FILES['photo']['name']);
      32.         $targetFile = $uploadDir . $fileName;
      33. 
      34.         move_uploaded_file($_FILES['photo']['tmp_name'], $targetFile);
      35.         $photoPath = $targetFile;
      36.     }
     
     У разі відсутності помилок зібрані дані зберігаються у вигляді масиву $profile, який записується назад у файл Profile_data.php за допомогою функції file_put_contents(). Функція var_export() перетворює масив на рядок PHP-коду. Після успішного збереження даних виконується перенаправлення користувача на сторінку профілю для оновленого перегляду.
     
      38.     if (empty($errors)) {
      39.         $profile = [
      40.             'firstname'   => $firstname,
      41.             'lastname'    => $lastname,
      42.             'birthdate'   => $birthdate,
      43.             'description' => $description,
      44.             'photo'       => $photoPath
      45.         ];
      46. 
      47.         file_put_contents('Profile_data.php', "<?php\n\$profile = " . var_export($profile, true) . ";\n?>");
      48. 
      49.         header('Location: main.php?page=profile');
      50.         exit;
      51.     }
      52. }
      53. ?>
     
     У HTML-частині сторінки виводиться заголовок «Your Profile». Якщо в масиві $errors є помилки, вони виводяться у вигляді списку червоним кольором. Далі розміщена форма, яка дозволяє користувачу редагувати своє ім'я, прізвище, дату народження, опис та завантажувати фотографію. Поля форми автоматично заповнюються раніше збереженими даними з масиву $profile. Якщо користувач раніше завантажував фото, воно відображається на сторінці. Завершується форма кнопкою для збереження змін.
     
      54. <h2>Your Profile</h2>
      55. 
      56. <?php if (!empty($errors)): ?>
      57.     <ul style="color:red;">
      58.         <?php foreach ($errors as $err) echo "<li>$err</li>"; ?>
      59.     </ul>
      60. <?php endif; ?>
      61. 
      62. <form method="post" enctype="multipart/form-data">
      63.     <label>First name: <input type="text" name="firstname" value="<?= htmlspecialchars($profile['firstname']) ?>"></label><br>
      64.     <label>Last name: <input type="text" name="lastname" value="<?= htmlspecialchars($profile['lastname']) ?>"></label><br>
      65.     <label>Birthdate: <input type="date" name="birthdate" value="<?= htmlspecialchars($profile['birthdate']) ?>"></label><br>
      66.     <label>Description:<br>
      67.         <textarea name="description" rows="5" cols="40"><?= htmlspecialchars($profile['description']) ?></textarea>
      68.     </label><br>
      69.     <label>Photo: <input type="file" name="photo"></label><br>
      70.     <?php if (file_exists($profile['photo'])): ?>
      71.         <img src="<?= $profile['photo'] ?>" alt="Profile photo" style="max-width:200px;"><br>
      72.     <?php endif; ?>
      73.     <button type="submit">Save</button>
      74. </form>
      
     PHP-скрипт  profile_data.php зберігає у змінній $profile асоціативний масив, що містить персональні дані користувача. Масив має п’ять ключів. Перший ключ 'firstname' містить ім’я користувача, в даному випадку це «Анастасія». Другий ключ 'lastname' зберігає прізвище користувача, яке дорівнює «Самосватова». Третій ключ 'birthdate' містить дату народження у форматі рік-місяць-день, де вказано 2006-05-18. Четвертий ключ 'description' містить текстовий опис користувача, де записано повне ім’я, по батькові та назву навчальної групи, а саме «Самосватова Анастасія Русланівна, студентка групи ПЗПІ-23-5». П’ятий ключ 'photo' зберігає шлях до зображення, яке завантажив користувач. Цей шлях вказує на файл у папці uploads/, ім’я якого починається з числового позначення часу, щоб уникнути однакових назв файлів, та закінчується ім’ям оригінального завантаженого зображення, у цьому випадку це 1748812498_зображення_2025-06-02_001457901.png. Цей файл використовується в основному профільному скрипті для відображення та редагування персональних даних користувача. Під час збереження змін дані з форми перезаписуються в цей файл у вигляді оновленого асоціативного масиву.
     
      1. <?php
      2. $profile = array (
      3.   'firstname' => 'Анастасія',
      4.   'lastname' => 'Самосватова',
      5.   'birthdate' => '2006-05-18',
      6.   'description' => 'Самосватова Анастасія Русланівна, студентка групи ПЗПІ-23-5',
      7.   'photo' => 'uploads/1748812498_зображення_2025-06-02_001457901.png',
      8. );
      9. ?>

     Cкрипт page404.php виводить сторінку помилки 404, яка спрацьовує, коли користувач намагається перейти на неіснуючу сторінку сайту. Спочатку за допомогою echo виводиться заголовок другого рівня з текстом «404 — Page Not Found». Далі за допомогою конструкції if перевіряється, чи встановлена в сесії змінна $_SESSION['user']. Якщо користувач не авторизований, тобто цієї змінної не існує, відображається повідомлення про відсутність доступу та пропонується перейти на сторінку авторизації за посиланням main.php?page=login. Якщо ж користувач авторизований, тобто змінна $_SESSION['user'] існує, виводиться повідомлення про те, що запитувана сторінка не існує, а також посилання для повернення на домашню сторінку сайту за адресою main.php?page=home. Таким чином, сторінка помилки одночасно виконує функцію повідомлення про помилку та пропонує варіанти подальших дій залежно від авторизації користувача.

1. <?php
2. echo "<h2>404 — Page Not Found</h2>";
3. 
4. if (!isset($_SESSION['user'])) {
5.     echo "<p>You are not authorized. Please <a href='main.php?page=login'>log in</a> to access this page.</p>";
6. } else {
7.     echo "<p>The page you are looking for doesn't exist.</p>
8.           <p><a href='main.php?page=home'>Back to Home</a></p>";
9. }
10. ?>
11. 


      ВИСНОВКИ
      У результаті виконання лабораторної роботи було створено повноцінний веб-додаток на мові програмування PHP із використанням сесій, форм, файлів та бази даних SQLite. Основною задачею було реалізувати структуру простого інтернет-магазину, який дозволяє користувачеві авторизуватись, переглядати товари, додавати їх до кошика, переглядати профіль та редагувати персональні дані. На початковому етапі проєкту було створено базу даних simple_shop.db з необхідною таблицею cart, що дозволяє зберігати інформацію про товари у кошику. Було налагоджено підключення до бази даних за допомогою PDO та обробку помилок під час встановлення з’єднання. Однією з основних частин роботи стало створення системи авторизації. Для цього було реалізовано файл credential.php з масивом користувачів та паролів. Сторінка авторизації перевіряє введені дані та за успішного входу створює сесію, яка зберігає ім’я користувача. Це дозволяє контролювати доступ до окремих сторінок та налаштовувати вигляд навігаційного меню залежно від стану авторизації. Для роботи з кошиком була створена функціональність додавання товарів та підрахунку їх кількості. Значення кількості товарів у кошику виводиться у навігаційному меню біля відповідного пункту. Окремо була реалізована сторінка профілю користувача. Користувач має можливість переглядати та змінювати свої дані. Дані профілю зберігаються у файлі Profile_data.php у вигляді PHP-масиву. Це дозволяє зберігати особисту інформацію між сесіями без використання бази даних. Також передбачено обробку помилок введення даних із виведенням відповідних повідомлень. Для організації переходів між сторінками використано єдиний файл main.php, який, залежно від переданого параметра page, підключає відповідні сторінки. Додатково була реалізована сторінка помилки 404, яка обробляє випадки неправильного введення адреси сторінки або спроби доступу до неіснуючих сторінок.
      
      

     ДОДАТОК А
     Посилання на YouTube
      
      Відеозапис презентації результатів лабораторної роботи: 
        https://youtu.be/fXVUtPVHuMs
    00:00 Привітання 
    00:14 - Файл main.php. Відкриття php тегу. Функція session_start. Підключення до файлу db.php 
    00:39 - HTML розмітка головної сторінки 
    00:50 - Встановлення шапки сторінки, яка винесена в окремий файл 
    01:03 - Визначаємо яку сторінку необхідно відкрити, перевірка значення $page 
    01:50 - Встановлення підвалу сторінки, який винесено в окремий файл 
    02:09 - Демонстрація файлу db.php, який є аналогічним до 3 лабораторної роботи 
    02:15 - Демонстрація файлу product.php, який є аналогічним до 3 лабораторної роботи 
    02:25 - Демонстрація файлу cart.php, який є аналогічним до 3 лабораторної роботи 
    02:42 - Файл header.php. Оголошення змінної cartCount. SQL-запит для підрахунку кількості товарів у кошику 
    03:32 - HTML-розмітка header, створення меню навігації та логіка його відображення 
    04:08 - Файл footer.php 
    04:18 - Файл login.php. Перевірка запиту, підключення файлу з масивом зареєстрованих користувачів та їх паролів. Перевірка правильності паролю 
    05:20 - Форма для введення логіна та пароля 
    05:49 - Файл logout.php 
    06:11 - Файл credential.php з логінами та паролями зареєстрованих користувачів 
    06:21 - Файл profile.php. Функція session_start. Підключення файлу з усіма даними користувача 
    06:46 - Перегляд файлу який підключили 
    07:02 - Створення масиву для зберігання повідомлень про помилки. Перевірка чи було виконано надсилання методом post 
    07:25 - Перевірка чи відповідають введені дані визначеним критеріям 
    07:53 - Збереження фотографії користувача 
    08:18 - Випадок коли помилок немає 
    08:48 - HTML-розмітка сторінки профілю 
    09:45 - Сторінка помилки 
    10:37 - Результат


    ДОДАТОК Б
    
    GitHub репозиторій: https://github.com/NureSamosvatovaAnastasiia/smp-pzpi-23-5-samosvatova-anastasiia/tree/main/Lab4/smp-pzpi-23-5-samosvatova-anastasiia-lab4
      
      
      
      

2


